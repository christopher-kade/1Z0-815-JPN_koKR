# 1. `while`문의 조건식

- 문제에서 `a`는 일단 무시해도 되는 수준
- 근데 `b`를 0에서 4까지 표시하고 싶댄다
- `while`문은 조건식이 `false`가 되면 바로 종료

# 2. `do ~ while`문

- 조건식이 아래에 있고, 세미콜론을 뒤에 붙이는 것이 특징
- 솔직히 써 본 적도 직접 코드에서 본 적도 없다
- 탈출하는 부분이 아래쪽이긴 한데 코드가 `a++`이므로 출력을 한 뒤에 인크리먼트가 된다
- 그래서 그대로 0~4까지 출력이 될 것이다

# 3. `while`문과 `do ~ while`문에서의 중괄호

- 중괄호를 생략하면 스코프에 들어가는 건 하나의 구문뿐이라는 걸 명심하기
- 중괄호 없이 안쪽에 두 개의 구문이 들어가면 곤란해진다
- 컴파일 에러다 그 말이다

# 4. `for`문의 조건식

- 일단 기본적으로는 `for ( 초기화문 ; 조건문 ; 갱신문 ) { 반복처리 }`의 형식을 취한다
- 초기화문에 들어가는 변수는 일시변수라 불리는데, 이건 2개 이상도 쓸 수 있다.
```java
for (int i = 0, j = 0; i < 3; i++) {
  // 반복처리
}
```
- 하지만 이 때 선언하는 일시변수는 반드시 모두 같은 타입이어야 한다
- 즉 `int i = 0, long j = 2` 이런 식으로 선언할 수는 없다는 이야기이다
- 하지만 문제에서는 그랬으므로 컴파일 에러가 뜬다

# 5. 변수의 스코프

- 초기화문에서  `int total = 0;`으로 선언되었지만 어디까지나 `for`문의 스코프 안에서만의 이야기이지, 밖에 나오면 그건 없는 변수다.
- 따라서 컴파일 에러.

# 6. `for`문의 조건문이 실행되는 타이밍

- 이거 진짜 귀찮아 죽겠다
- 일단 코드부터 쓰고 보자
```java
public class Main {
	public static void main(String... args) {
		for (int i = 0; /* 문제의 부분 */ ; i++) {
			sysout(i);
		}
	}
}
```
- 자 그럼 콘솔에 `0`만 출력되게 하려면?
- 그냥 간단하게 생각하면 된다. 코드에 먼저 나와 있으니까 판정도 나중에 이루어진다.
- 즉 `i < 0`을 골라버리면 그냥 그대로 `for`문이 끝나버린다.
- 따라서 해당 상황에 맞는 조건은 `i == 0`

# 7. `for`문에서 일시변수를 두 개 선언할 때

```java
public class Main {
	public static void main(String... args) {
		for (int i = 0, j = 0; i < 3/*,  j < 5*/; i++) {
				sysout(i++);
				j += i;
			}
	}
}
```
- 컴마를 사용 가능한 부분은 초기화문과 갱신문 뿐
- 두 개를 굳이 넣고 싶으면 컴마를 쓰지 말고 논리연산자나 메서드를 사용해야 한다
  - 컴마가 쓰이는 데는 선언문인데 조건문에 들어갈 건 논리값이라 문법에 맞지 않는다
  - 즉 제대로 쓰려면 `i < 3 && j < 5`라고 써야 한다
- 컴파일 에러가 난다는 말

# 8. `for`문의 갱신문

- 7번 문제와 같이 컴마를 사용 가능한 부분 되시겠다
```java
// ...
for (int i = 0; i < 3; i++, period()) {
	sysout(i);
}
// ...
```
- 이 때 재정은 다음과 같이 진행된다
	1. 변수가 선언되어 0으로 초기화된다
	2. 조건문의 판정이 진행된다. 0은 3보다 작으므로 다음으로 넘어간다.
	3. 콘솔에 `i`가 찍힌다
	4. `i++`로 인크리먼트가 된다
	5. 그리고 `period()` 메서드가 실행된다
	6. 2로 돌아가 다시 판정한다.
- 대충 알겠지? 그러니까 범위를 넘었는지 판정하기 전에 갱신문은 반드시 실행된단 이야기
- 즉 맨 끝에 컴마는 반드시 나온다

# 9. 중첩 반복문

- 풀이가 엄청 길다. 머리 터지는 문제는 맞는 모양이다.
- 일단 배열을 살펴보자. `array.length`는 안은 배열의 요소 수이므로 안긴 배열이 2개기 때문에 2이다.
- 그리고 `array[i][j]`에서 앞쪽 인덱스는 0과 1밖에 불과하기 때문에, 뭔가 `j`가 들어가면 안 될 거 같아서 선택지에서 제외해 보았다. 벌써 2개밖에 안 남음.
- 글고 `array[i].length`까지 반복하는 게 제대로 다 조회하는 거 같잖어.
- 그리고 `j = i`부터 시작하니까 합이 10이 깔끔하게 나온다.
- 끗!

# 10. 무한루프가 되는 조건

- `while(true)`
- `for`의 조건문 부분이 항상 `true`
- `for`의 조건문 부분을 생략

# 11. `foreach`문

- 솔직히 너무 많이 썼다
- 여튼 `for ( [성분의 자료형] [성분의 변수명] : [집합])` 형태로 쓴다.
- 2차원 배열은 사각괄호를 하나 빼면 되겠지?

# 12. `String`의 불변성

- `str`은 그냥 임시변수일 뿐, 이게 `"D"`를 가리키게 된다고 해서 배열의 요소들이 다른 걸 가리키게 되거나 하진 않는다
- 즉 그 다음 코드에서 새로이 `str`로 요소를 가리키게 되면 원래의 배열 요소들을 다시 가리키게 된다

# 13. `do ~ while` 문과 `while`문의 차이

```java
int num = 10;
do {
	num++;
} while (++num < 10);
sysout(num);
```

- 일단 이 코드에서 `num`은 최종적으로는 12가 된다
- A는 11이 나옴
- B는 11이 나옴
- C는 10이 나옴
- D는 13이 나옴

# 14. `break`를 사용한 반복문의 중지

- 일단 `a`는 어디에도 보이지 않으니 그냥 두 번 반복한단 뜻이 되겠다
- 그리고 `"B"`가 나오면 출력 없이 `break`된단 뜻이기도 하다
- 즉 `"A"`가 두 번 이어서 나온다

# 15. `continue`를 이용한 반복문의 제어

- `continue`는 이 다음의 코드를 실행하지 않고 그대로 다음 루프로 건너뛴다는 이야기
- 짝수이면 건너뛰고, 홀수이면 합에 더하는 모양새가 된다

# 16. 라벨의 사용

- 도대체 라벨이 뭐여?
- 예컨대 이런 거다

```java
sample :
for (int i = 0; i < 10; i++) {
	for (int j = 0; j < 0; j++) {
		if (j > 3) {
			break sample;
		}
	}
}
```

- 이 때 `break`나 `continue`를 이용해 중첩 반복문의 한 코드 블럭만 건너뛰는 게 아니라, 전체 코드 블럭에 라벨을 붙여 그 라벨을 건너뛸 수 있게 된다는 소리다
- 라벨은 다음과 같은 코드에 붙일 수 있다:
  - 코드 블럭
  - 모든 반복문과 분기(`if`, `switch`)문
  - 식
  - 대입
  - `return`문
  - `try` 블럭
  - `throw`문
- 그러니 답은 '전부'다

# 17. `break`와 `continue`, 라벨, 그리고 이중 반복문의 조합

```java
int total = 0;
a : for (int i = 0; i < 5; i++) { // 일반적인 0 ~ 4 반복문
	b : for (int j = 0; j < 5; j++) {
		if (i % 2 == 0) continue a; // 짝수면 a 반복은 바로 다음 반복으로 넘어간다
		if (j > 3) break b; // 3보다 크면 b 반복은 끝난다
		total += j; // 그러지 않은 모든 j값은 total에 더해진다
	}
}
sysout(total);
```

- 하나하나 생각해 보면, `j`는 0, 1, 2, 3이 될 수 있고, `i`는 `total`에 코빼기도 보이지 않으므로 실제적으로 홀수 부분의 3차례만 안쪽의 반복문이 실행된다는 뜻이라 해석할 수 있다.
- 라고 생각하면 합은 `18`이어야 할텐데 왜 `12`가 정답인 것일까?
- 사실 반복은 2차례만 되는 것이었다
- 바보야