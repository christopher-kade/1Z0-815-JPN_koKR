# 들어가기 전에: `var`

- 일명 "형추론형"
- 타입을 지정할 필요성을 줄여 준다
- 예컨대 우리가 컬렉션 같은 걸 선언할 적에 `List<String> Obj1 = new ArrayList<String>();`이라고 많이 하는데, `var`형을 쓰게 되면 `var Obj2 = new ArrayList<String>();`으로 줄여 쓸 수 있다는 것이다.

- 클래스 이름이 엄청 길 때도, 예컨대 뭐 `ClassNameSoLongThatAnyoneCantTypeItWithoutAutocomplete`라는 클래스가 있다고 하면 이 클래스 객체를 선언할 때 꽤 보기가 거추장스러워지겠지만, `var`형을 쓰면 이게 좀 더 보기 쉬워진다.
```java
ClassNameSoLongThatAnyoneCantTypeItWithoutAutocomplete bad = 
    new ClassNameSoLongThatAnyoneCantTypeItWithoutAutocomplete(); // that's nono
var good = new ClassNameSoLongThatAnyoneCantTypeItWithoutAutocomplete(); // 짧다!
```
- 또는 숫자 리터럴 넣을 때 어차피 `L`이라던가 `F`라던가 넣으니깐 좀 깔끔하게 보일 수 있을 것이다
```java
var i = 1; // int
var l = 23L; // long
var d = 3.2; // double
var f = 2.43f; // float
```
- `var`형은 선언할 때 처음 들어간 자료형으로 변수 형태가 고정된다
- 이 고정으로 인해 주의할 점이라면, 흔히 다형성을 사용할 때 부모 클래스 타입으로 참조형을 선언하는데, 이 때 `var`을 사용해서 자식 클래스로만 선언을 하게 되면 부모 클래스 타입이 언급되지 않았으므로 이 `var`는 그대로 자식 클래스의 타입으로만 되어버린다는 것이다.
- 그러니까 `A`라는 부모 클래스 밑에 `B`랑 `C`라는 자식 클래스가 있다면,
```java
A obj1 = new B();
obj1 = new C(); // A 타입이기도 하므로 다형성으로 문제 없음
var obj2 = new B();
// obj2 = new C(); // B 타입이므로 컴파일 에러
```
- 이 된다는 것이다.

# 1. 유 저스트 액티베이티드 마이 트랩 카드

- 자바에서 논리형은 `bool`이 아니라 `boolean`이다. 즉 뭘 출력해보기도 전에 컴파일에러가 날 수밖에.
- 정답은 컴파일에러가 나는 C

# 2. 정수 리터럴의 대입

- `long`형은 끝에 `L`이나 `l`을 붙인다, 똑같이 `float`형은 끝에 `F`나 `f`를 붙인다
- Java SE 7부터 추가된 기능이, 각각의 진수별로 접두어를 붙여서 정수형에 대입할 수 있다는 기능이랜다
```java
int dec = 24; // 10진수
int oct = 077; // 앞에 0을 붙여 8진수
int hex = 0x3F; // 앞에 0x를 붙여 16진수
int bin = 0b11100111 // 앞에 0b를 붙여 2진수
```
- 즉 이걸 모르니 못 푸는 게 당연하단 소리다
- 정답은 앞에 0이 붙어 있으면서 존재 불가능한 자릿수인 8이 들어간 E

# 3. 언더스코어(`_`)

- 숫자가 무지하게 긴 게 있다고 생각해 보자. `4294967296` 같은 거.
- 아니면 `20000000000` 같은 거. 이게 정확히 얼마나 큰 숫자인지 감이 잘 안 잡히잖어.
- 그래서 Java SE 7부터는 자릿수 '중간'에 언더스코어 `_`를 넣어서 조금 보기 쉽게 숫자를 코드에서 표현할 수 있게 했다는 것이다.
```java
int billion = 1_000_000_000;
long thirtytwo = 4_294_967_296L;
long pain = 20_000_000_000L;
```
- 주의할 점은, 이게 모든 자릿수에 전부 대응하긴 하지만 자릿수 앞이나 뒤에 와서는 안 된다는 것이다. 소수점형의 소수점 앞뒤도 마찬가지.
- 이 설명에 해당하는 선택지는 C, D, E, F, I가 되시겠다.

# 4. `char`형

- 딱 한 글자만 들어가고, ASCII 테이블에 대응하는 127개의 문자로만 이루어져 있는 변수
- 문자 리터럴은, 작은따옴표 '로만 대입할 수 있다
- 그래서 ''안에 여러 문자를 써도 안 되고, ""로 큰따옴표를 써도 안 되고, 문자 리터럴이 아닌 `null`이어도 안 된단 소리다
- 근데 숫자를 따옴표 안에 안 넣고 그냥 대입해도 되는데, 이렇게 되면 아스키 테이블 안의 번호에 해당하는 문자로 대입이 된다
- 예컨대 `char zero = '0'`을 넣으면 사실은 아스키 테이블의 48번 기호가 들어가는 것과 똑같기 때문에 `char zero = 48`로 대입하면 똑같은 결과가 나온다는 것이다

# 5. 식별자의 명명 규칙

- 변수나 메서드, 클래스 등의 이름을 자바에서는 식별자(identifier)라 부른다
- 기본적으로 프로그래머가 마음껏 정할 수 있으나, 다음과 같은 제약이 있다.
  - 키워드는 안 됨
  - 기호는 통화기호(백슬래시?)와 언더스코어 뿐
  - 숫자부터 시작하면 안 된다(2글자째부터는 괜찮다)
- 키워드는 아주 긴 목록이 있으나 생략한다
- 생각해 보면 중괄호는 코드블럭이란 뜻이니까 절대로 쓰면 안 된다
- 그래서 이래저래 하면 답은 D, E

# 6. `var`를 사용한 변수선언

- 위에서 좀 다뤘으니까 생략
- `null`도 안 돼
- 람다형으로도 형추론은 안돼
- 배열형도 안돼
- 앞에 타입 선언을 안 했으니까 뒤에 다이아몬드 연산자`<>`도 안 될 거 같은데
  - 사실 형이 선언이 안 됐으므로 `Object`형이 들어간 걸로 취급한댄다. `ArrayList<Object>()` 같이 말이다.
  - 영문을 모르겠지만 그렇다니 그렇다고 하겠다.

# 7. `var`를 사용한 변수선언(2)

- 역시 생략
- `var`로는 로컬변수밖에 선언하지 못함
  - 클래스의 필드를 선언할 적에는 `var`로 형을 추론할 수 없음
  - 답은 컴파일 에러

# 8. `var`를 사용한 변수선언(3)

- 형추론은 **컴파일 시**에 이루어짐
- 그래서 변수 `a`의 타입은 컴파일 시에 B로 타입이 정해지고, 다음 라인에서 C 타입을 참조하려 했기 때문에 컴파일 에러가 나는 구조

# 9. `java.lang.String` 객체 생성

- `new` 키워드로 인스턴스화
- 큰따옴표(`""`)로 감싼 문자열 리터럴로 기술
- 하는 게 `String` 클래스의 인스턴스를 생성시키는 대표적인 두 가지 방법
- `valueOf()`를 쓰는 팩토리 메서드도 있기는 한데 선택지에서는 작은따옴표로 리터럴을 감싸서 넣었기 때문에 에러

# 10. `String` 객체의 불변

- 한 번 설정한 필드의 값을 앞으로 변경할 수 있는 객체가 있고 변경할 수 없는 객체가 있는데
- 전자를 가변(mutable) 객체라 부르고, 후자를 불변(immutable) 객체라 부른다
- immutable한 객체는 다음과 같은 특징이 있다
  - 모든 필드가 `private`
  - 세터 메서드가 없음
  - 클래스 선언이 `final`: 메서드를 오버라이드할 수 없음
  - 내부에 가변 객체가 있어도, 그것을 꺼낼 수 없음 = 게터 메서드가 없음
```java
public final class Sample {
  private final String name;
  public Sample(String name) {
    this.name = name;
  }
  public void greet() {
    System.out.println("Hello, " + name);
  }
}
```
- 이런 거.
- 대표적으로 `java.lang.String`이 있고 `java.io.File`도 있다고 함
- `String`의 경우 이러한 불변성 때문에 문자열을 변경하기 위해서는 변경한 문자열의 인스턴스를 새로 대체하여 넣는 식으로밖에 변경할 수 없음
- `replaceAll()` 메서드를 사용하면 해당 객체가 바뀌는 게 아니라 바뀐 객체를 돌려주는 형식이 된다. 즉 `String new = old.replaceAll(a, b)`가 되어야 하는 것
- 즉 바뀐 객체를 다시 넣지 않는 한 원래 객체는 바뀌지 않는다

# 11. `charAt()` 메서드

- 지정한 위치에 있는 문자 하나만 쏙 빼서 돌려준다
- 이 때 인덱스는 0부터 시작한다
- 범위를 벗어나면 화려하게 SIOOBE(AIOOBE의 문자열 버전)를 맛보게 된다
- 예외가 던져진다 그런 얘기다

# 12. `indexOf()` 메서드

- 이건 이제 찾는 문자의 인덱스를 알려주고, 이것도 0부터 시작하는 인덱스
- 근데 찾지 않는 문자가 들어가 있으므로 SIOOBE일까나? 아마 그럴 것 같은 예감이 든다
- 어쨌든 예외가 던져진다 그런 말이다

# 13. `substring()` 메서드

- 아마도 자바에서 글자 파싱할 때 제일 많이 썼던 거 같은 메서드
- 처음 보는 사고방식이다: 어느 글자의 '사이'부터 '사이'까지를 자를지 인수에 넣는 식이랜다
- 확실히 그렇게 이해하면 쉽네

# 14. `replace()` 메서드

- 모두 찾아서 치환한다는 간단한 규칙
- 참고로 `replace()`는 `char`형 2개 받는 거랑 `CharSequence`형 2개 받는 형태가 있는데, 문제에서 나온 건 후자.
- `String`이 `CharSequence` 인터페이스의 구현이기 때문에 가능한 일. 이 때 `char`랑 `CharSequence`를 섞어서 인수로 넣을 순 없으니 주의.

# 15. `length()` 메서드

- 해당 문자열의 길이를 돌려주는 메서드
- 당연한 얘기지만 이걸로 `charAt()`을 찾으면 인덱스가 0으로 시작하기 때문에 그냥 넣을 수는 없다
- 즉 SIOOBE의 쓴맛을 보게 된다는 것이다
- 바보야

# 16. `startsWith()` 메서드

- 돌려주는 건 불리언이다
- 문제의 substring은 1부터 3까지이므로 `"bc"`
- 즉 `b`부터 시작하느냐는 질문은 `true`가 돌아오게 된다
- 참고로 `endsWith()`도 있다. 사용법은 동일.
- 메서드 체인이란 방법을 썼는데 다 알지?

# 17. `String` 객체

- `concat()` 메서드가 정답
- `append()` 메서드는 `StringBuilder` 클래스에서 사용되는 메서드

# 18. `+` 연산자

- 우선 앞에 있는 놈들은 `int`이므로 연산이 이뤄져서 30이 된다
- 그럼 `sysout`의 인수는 이제 `30 + "30" + 40`이 되는데...
- `+` 연산자의 경우 어느 한 쪽이 문자열이면 다른 한 쪽도 문자열로 변환하여 연산을 처리한다
- 주의할 점은 이게 앞에서부터 연산이 처리되기 때문에, 예컨대 `10 + 20 + "30"`을 하면 앞에서 더하기가 처리돼서 `30 + "30"`과 동치가 되는데,
- `"30" + 10 + 20`을 하면 일단 `"30" + 10`이 먼저 처리돼서 `"3010"`이 되어버려서, 뒤에 있는 20도 문자열로 변환되어 `"301020"`이 되어버리는 식
- 지식이 늘었다

# 19. `+=` 연산자

- 다들 알지? 근데 틀림
- 왜냐면 `+` 연산자 판정을 내가 잘못 알아서 그렇습니다 젠장
- `null + "null"`이면 앞의 `null`이 문자열 변환이 돼서 결과적으로는 `"nullnull"`이 된다
- 바보야

# 20. `java.lang.StringBuilder` 클래스

- 이건 `StringBuilder`에 대한 이해가 필요한 문제
- 기본 이 클래스는 버퍼 사이즈가 16문자분이 주어진다. 이게 뭔 소리냐면:
```java
public StringBuilder() {
  super(16); // 상위 클래스 생성자에 16을 넣음
}
```
- 그래서 상위 클래스의 생성자에 가 보면:
```java
abstract class AbstractStringBulilder implements Appendable, CharSequence {
  
  char[] value; // 실제 들어가는 문자의 배열

  AbstractStringBulilder(int capacity) {
    value = new char[capacity]; // 입력된 정수만큼의 크기를 가지는 배열을 할당
  }

  // ...
  // 이하 생략
}
```
- 만일 `StringBuilder`의 생성자에 문자열이 들어가는 형식이 된다면, 그러니까 가변 문자열 객체에 미리 문자열을 넣어둔다면:
```java
public StringBuilder(String str) {
  super(str.length() + 16);
  append(str);
}
```
- 즉 문제에서 인스턴스 생성을 5글자 문자열로 했기 때문에, 이 인스턴스의 총 용량을 나타내는 메서드 `capacity()`를 부르면 21이 나온다는 뜻이다.

# 21. `java.lang.StringBuilder.append()`와 `reverse()`, `replace()` 메서드

- 문제에서는 비어 있는 `StringBuilder` 인스턴스를 생성한 다음
- 다음 줄에서 `"abcde"`를 `append()`하고,
- `reverse()`로 들어가 있는 문자열의 순서를 바꾼 다음에,
- 이제 문제가 `replace(int start, int end, String str)` 메서드의 이해가 되겠다.
- 우리가 시작과 끝을 어떻게 처리하는지는 다 배웠다.
- 즉 1과 3 사이의 문자를 지정한 문자열로 치환하는 건데... 이걸 헷갈린 거다
- 답은 `"edcba"`의 `1, 3` 부분을 `"a"`로 치환하는 거니까, `"eaba"`가 된다.

# 22. `indexOf()` 메서드

- 당연히 0부터 시작하지?
- `"bcd"`가 있는 자리는 1이다