# 1. 배열의 특징

- 배열이란? 값의 집합을 다루기 위한 '인스턴스'
- C언어같이 같은 타입의 변수를 모아 놓은 걸 그냥 배열이라 하는 경우도 있으나...
- 자바에서 배열은 **배열 클래스**에서 만들어진 **인스턴스**이며, 값의 집합을 다루기 위한 목적을 띠고 있다
  - **값 그 자체**와, **값의 집합을 다루는 인스턴스**는 다르다는 것에 주의
  - 그리고 이 배열에서 다루는 값을 **요소**라 한다는 것이다
  - 배열은 어디까지나 인스턴스라, `new` 키워드로 생성해야 한다는 것을 기억하기
- 또 배열은 프리미티브 타입을 사용하는 유형과 객체 타입을 사용하는 유형 두 가지로 나뉘는 것도 기억하기
- `new int[3]`으로 생성, `int[] array`로 선언
- 참고로 문제의 `int[] array = new int[0];`도 문법상의 오류는 없으며, 그냥 요소가 하나도 없는 배열형 인스턴스가 될 뿐이다
- 그리고 문제와 같이 `toString` 메서드를 쓸 경우, 배열 클래스는 그냥 그대로 `Object` 클래스의 `toString` 클래스를 사용하여 다음과 같이 문자열을 출력한다:

```java
public String toString() {
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

- 그래서 메모리 주소를 담은 해시코드가 출력된다 그 말이다.
- 참고로 `getClass` 메서드는 해당 클래스의 인스턴스를 `Class`형으로 돌려주고, 이 클래스 자체의 조작을 실행할 수 있게 도와준다. `getName`처럼 말이다. 또한 `getCanonicalName`처럼 해당 클래스의 자료형을 돌려줄 수도 있다.

# 2. 배열 타입 변수의 선언 방법

- 일단 기본은 `int[] array;`
- 그리고 `int array[];`
- 2차원 배열의 경우 `int[][] array2D;`로(또는 괄호를 변수명 쪽으로 해도 무방)
- 3차원 배열의 경우 `int array3D[][][];`로(또는 괄호를 타입 쪽으로 해도 무방)
- 또 `int[] array2D[];` 역시 2차원 배열이다
- `int[][] array3D[];` 역시 3차원 배열이다

# 3. 배열 타입 변수의 선언 방법(2)

- 문제에서 요구하는 것은 배열 타입 변수와 배열 인스턴스, 그리고 그 요소에 대하여 명확하게 이해하고 있는가이다
- 배열형 변수에는 배열 인스턴스에의 참조만 대입됨을 기억하기
- 즉 배열형 변수는 그 변수가 배열 인스턴스를 가리킨다는 것만이 기억될 뿐, 그것의 요소가 몇 개인지와는 전혀 관계가 없다
- 그래서 선언부에서 타입에 숫자를 넣게 되면(e.g. `int[2] array;`) 컴파일 에러가 나온다는 뜻이다
- 그리고 문제의 모든 선택지에는 타입 선언부 괄호 안에 숫자가 있다

# 4. 배열 인스턴스의 생성 방법

- 하지만 배열 **인스턴스**를 생성할 때에는, 반드시 배열의 요소 수를 지정해야 한다.
  - 이렇게 하면 안 된단 뜻이다: `int[] array = new int[];`
  - 소수점도 안 된다: `int[] array = new int[2.3]`
- 그럼 `int[][] array = new int[3][3];`으로 선언하면 어떻게 될까?
  1. 3개의 요소를 가진 1차원 배열 인스턴스가 만들어지고,
  1. 3개의 요소를 가진 1차원 배열 인스턴스 3개가 만들어진다
  1. 첫 번째(1차원째) 배열의 세 요소에 두 번째(2차원째) 배열 3개의 참조가 들어간다
- 그러니까 동시가 아니라 반드시 저 순서대로 만들어진다는 재정
```java
int[][] array = new int[3][];
array[0] = new int[3];
array[1] = new int[3];
array[2] = new int[3];
```
- 참고로 각 배열의 요소 배열은 다른 요소랑 반드시 요소 수가 같으라는 법은 없다
- 0번 배열이 2개짜리에 2번 배열이 4개짜리여도 된단 소리다

# 5. 배열 인스턴스와 요소의 값

- 배열 인스턴스와 요소는 다른 것
- 즉 요소에 직접 값을 대입하지 않는 이상 인스턴스의 요소는 초기화된 값만 존재한다
- 예컨대 정수면 0이고 부동소수점이면 0.0이고 진리값이면 `false`고 문자면 `\u1000`이라고 하고...
- ...객체면은 `null`로 초기화된다는 뜻이다
- 말하자면 객체 타입의 배열을 만들면 그냥 객체 모양의 구멍이 있고 초기화까지 끝난 실제 객체가 들어가 있지는 않다는 뜻
- 그렇다는 건 문제의 코드를 실행시키면 그 유명한 ぬるぽ(java.lang.NullPointerException)가 나온다는 거다. ガッ
  - 이거 일본 비즈니스 회화에 나옴 진짜임(※아닙니다)

# 6. 배열의 요소와 인덱스(添え字)

- 초기화 연산자(`{}`)를 사용해서 배열 인스턴스의 생성과 요소의 초기화를 동시에 할 수 있음
- 0번 인덱스에 `null`을 대입하면 이건 리터럴의 한 종류이므로 그대로 요소에의 참조가 사라진다
- 그리고 이걸 그냥 문자열화하면 그대로 `null`이 출력된다는 소리

# 7. 배열 인스턴스의 생성, 초기화, 배열 타입 변수의 참조를 대입하는 형식

- 초기화 연산자가 있겠지.
  - `int[] array = { 2, 3 };`
- 그리고 `new`를 써도 똑같이 선언이 가능하지만...
  - `int[] array = new int[]{ 2, 3 };`
  - 정말 주의할 점은, `new`를 쓸 때는 대괄호 `[]` 안에 요소 수를 지정하면 안 된다는 점이다.
  - 이는 초기화 연산자로 자동적으로 배열의 요소 수가 지정되기 때문이다
  - 컴파일 에러가 나버려!
- 요소가 없는 배열의 생성
  - `int[] array = {};`
  - 또는 `int[] array = new int[0];`
- 다차원 배열의 생성
  - `int[][] array = { { 2, 3 }, { 4, 5} };`
  - 이렇게도 생성 가능하다: `int[][] array = new int[][]{};`
  - 그러니까, 대괄호 갯수를 빼먹으면 안 된다는 소리다.
  - 중괄호만 덜렁 써놔도 일단 되긴 된다: `int[][] array = {};`
  - 참조를 선언한 다음에 차원수를 명시해서 인스턴스를 넣어도 된다

# 8. 다차원 배열의 특성

- 다 좋은데, ぬるぽ(NPE)가 출현하는 것이 문제라 할 수 있겠다
- 1번 인덱스가 `null`이니까 이건 뭐 길이를 구하려고 하면 당연히 예외가 튀어나오겠지?

# 9. 상속과 구현의 관계, 이에 따른 인터페이스의 인스턴스의 동작

- 어떤 클래스가 다른 클래스를 상속했을 때, 부모 클래스의 형태로 배열을 만들어서 안에 저장할 수 있다
- 문제의 클래스는 다들 예쁘게 상속 관계 상에 있으므로, 컴파일 에러가 나지 않는다
- 당연히 `Object` 형으로부터도 상속되어 있고, 딱히 뭔가 객체를 쓰는 일도 없으니까 그대로 실행될 뿐이다

# 10. `clone` 메서드

- 참조는 다르지만 내용은 같은, 말하자면 동치성을 지니는 서로 다른 배열을 만드는 메서드

```java
int[] arrayA = { 1, 2, 3, 4 };
int[] arrayB = arrayA.clone();
sysout(arrayA == arrayB); // 동치일 뿐 참조는 다르므로 false
for (int i : arrayB) {
  sysout(i); // 정직하게 1\n2\n3\n4\n이 표시된다
}
```
- 이런 느낌이다
- 글고 문제에서 되게 예쁘게 이중반복문을 넣은 것도 특기할 만한 점