# 1. 클래스와 그 인스턴스

- 클래스 파일이 정의되면 인스턴스는 거기서 정의를 복사해 가져와서 메모리 공간에 올려놓은 것
- 단 완전히 복사는 아니고 `static`한 친구들은 인스턴스에는 복사되지 않는다
- 인스턴스 여러 개를 만들면 여러 개가 복사된다는 뜻이다
  - 즉 인스턴스 각각의 다른 값을 가질 수 있게 된다는 뜻이다
- 문제에서는 두 인스턴스는 다르기 때문에 `a.getNum()`을 하면 `a`의 `num`을 가져오게 될 뿐이다

# 2. 참조형 변수가 가진 인스턴스의 참조

- 문제에서 만들어진 인스턴스는 2개긴 하다
  - `apple`, `200`의 필드를 가진 인스턴스 `a`와 `banana`, `100`의 필드를 가진 인스턴스 `b`로
- `a`랑 `b`는 참조형 변수로써 각각의 인스턴스의 실제 주소를 가리키고 있다
- 문제 코드에서 `a = b`라고 하면 `b` 인스턴스의 참조를 `a`에 대입한 것
- 이걸 `printInfo()`로 인스턴스의 필드 내용을 출력하게 되면 `banana, 100`이 출력되게 된다

# 3. 리터럴

- 소문자 `null`이면 조금 고민해 봤을 텐데 대문자 `NULL`이라서 빼도 박도 못하고 문자열이 들어갈 수밖에 없게 되었다
- `null`인 클래스는 `toString`을 하면 `null`이 표시된다는 건 세상이 다 알지만 나머지는 다르단 것이다
- 말인즉슨 자바는 당연하게도 대소문자 구분을 한다는 것이다

# 4. 가비지 컬렉션의 타이밍

- 가비지 컬렉션이라 함은 메모리 용량 절약을 위해 사용하지 않게 된 인스턴스를 메모리에서 지운다는 뜻
- 알다시피 JVM의 매우 특별한 기능 중 하나이다
- **어디로부터도 참조되지 않게 된 인스턴스**가 그 대상
  - `null`을 대입했을 때라던가
  - 새로운 인스턴스의 참조로 변수를 덮어쓴다던가
- 문제에서 묻는 건, 7행까지의 실행이 모두 **끝났을 때**의 가비지 컬렉션 대상을 묻는 거니까, 실행 종료 시점에서 인스턴스가 남아 있는 건 4행에서 생성된 `b`가 가리키는 참조의 인스턴스다.

# 5. `static`한 필드로의 접근

- 자바 소스 파일 `.java`를 컴파일하면 바이트코드인 `.class` 파일이 생성되고, 이 파일을 JVM이 읽게 하는 걸 클래스 파일을 **로드**한다고 표현한다.
- 이게 로드될 적에, `static`(정적)으로 수식된 필드나 메서드는 JVM의 **정적 영역**이라는 별도의 메모리 영역에 배치가 되는데, 이것 이외의 부분은 **힙 영역**이라는 곳에 배치된다.
- 인스턴스가 생성될 때에는 이 힙 영역에 있는 클래스의 정의에 따라서 인스턴스가 생성된다.
- 이때 이 정적 멤버와 그렇지 않은 멤버의 구분은 바이트코드가 로드된 뒤 바로 일어난다.
- 이렇기 때문에 정적 필드는 인스턴스를 만들이 않아도 사용할 수 있게 되는 것이다
- 주의할 점이라면 이 때문에 **인스턴스**에는 정적 멤버가 존재하지 않는다는 점
- 아까도 말했듯이 인스턴스가 생성되면 힙 영역에 있는 부분만 복사되기 때문
- 이 때문에 만일 인스턴스의 참조 변수를 통해서 정적 필드에 접근하게 되면, 각각의 인스턴스에 관계없이 해당 클래스의 인스턴스가 사용하는 모든 해당 필드를 변경하는 것과 같은 것이 된다
- 따라서 답은 마지막으로 수정된 값을 따르게 됨

# 6. 정적 멤버들의 규칙

- 5번에서도 말했지만 정적 멤버는 따로 정적 영역에 존재하고, 힙 영역의 다른 멤버들이 인스턴스 영역에 복사되는 식으로 인스턴스가 생성된다
- 이 때문에 인스턴스가 필요하냐 필요하지 않느냐를 따지는 것으로 보기를 걸러낼 수 있다
- 정적이지 않은 멤버가 무언가를 한다는 건 인스턴스에서 무언가를 한다는 뜻
- 정적인 멤버가 무언가를 한다는 건 인스턴스가 없는 상태에서도 가능하다는 뜻

# 7. 인스턴스 메서드를 부르는 방법

- 예컨대 클래스 `Sample`가 있고 정적 메서드 `statFunc()`와 인스턴스 메서드 `instFunc()`가 있다고 생각해 보자
- 아니 뭐, 코딩해 보면 이렇다
```java
class Sample {
  public static void statFunc() { sysout("Static Method"); }
  public void instFunc() { sysout("Instance Method"); }
}

public class Main {
  public static void main(String[] args) {
    Sample samp = new Sample(); // 인스턴스 생성(인스턴스 영역에 클래스 복사)
    Sample.statFunc(); // 정적 영역에 있으므로 클래스 이름으로 부른다
    samp.instFunc(); // 인스턴스 영역에 있으므로 인스턴스 참조로 부른다
  }
}
```
- 말인즉슨 인스턴스 메서드는 인스턴스 참조로 부르라는 간단한 이야기

# 8. 메서드 호출과 시그니처

- **시그니처란?**: 메서드 이름과 그 인수들의 리스트
  - 예컨대 `func`라는 이름의 함수가 있다고 치면
  - 이 녀석이 `int a, int b`를 인수로 받는 녀석도 있을 것이고
  - `String a, String b`를 인수로 받는 녀석도 있을 것이다
  - 이 때 오버로딩된 `func`의 구분을 시그니처로 한다는 개념
  - 전자는 `func(int a, int b)`가 시그니처,
  - 후자는 `func(String a, String b)`가 시그니처인 셈이다
- 이걸 왜 설명했냐면 JVM이 메서드를 찾아내는 구조가 있기 때문이다
  - 예컨대 아까처럼 `func`라는 글자를 컴파일러가 찾았는데, `samp.func`라고 되어 있는지 일단 먼저 확인해서 인스턴스 메서드인지 알아보고,
  - 그리고 `Sample.func`라고 되어 있는지 알아보고,
  - 그리고 `samp.func(10, 20)`일 경우에 지금 들어간 게 두 개의 `int` 인수니까 시그니처인 `func(int a, int b)`로 메서드를 찾을 것이고 `samp.func("AAA", "BBB")`이면 두 개의 `String` 인수가 들어가는 시그니처의 메서드를 찾을 것이다 그 말이다
- 여튼, 보기에서는 인수가 충분히 안 들어갔는데 딱히 오버로딩된 메서드도 없으므로 컴파일 에러

# 9. 지역(로컬) 변수의 선언

- 자바는 C언어랑 다르기 때문에 그냥 어디든지 지역 변수를 선언할 수 있다
- 하지만 순차처리 규칙이라는 프로그래밍의 대명제가 있기 때문에 선언하기 전의 열에서는 그 변수는 없는 것이다. 뒤에 선언되어 있다고 쓸 수는 없는 것이다...
- 그러므로 문제의 열에서 `c`는 없는 변수
- `d`는 뭐 코드에조차 존재하지 않는다

# 10. 메서드의 정의

- 이건 코드를 봐야 이해가 쉽겠지?
```java
public int func(int param) {
  // [접근 제한자] [리턴 타입] [메서드 이름]([인수 타입] [인수 이름]) {
  int result = param * param;
  // 메서드 내 처리
  return result;
  // return [리턴 값];
}
```
- 당연한 얘기지만(사실 별로 안 당연함) 리턴 값의 타입은 반드시 선언된 리턴 타입과 일치해야 한다
  - `void` 메서드의 경우 반드시 어딘가에서 메서드를 끝내고 싶을 땐 `return;`을 하면 된다
  - 그렇지 않을 경우에는 딱히 써 줄 필요는 없음
- 여튼 리턴 타입과의 일치, 그리고 코딩 순서 같은 것을 잘 기억할 것

# 11. 메서드의 호출과 리턴값

- 메서드 정의에서 `void`라고 분명히 그랬는데 `String val = s.setValue("Hello");`라고 해도 곤란하다
- 아니 뭐 데이터베이스 드라이버 같은 데서 실행 여부를 불리언으로 돌려주지만 그냥 `void`처럼 대입 없이 쌩으로 실행시키는 형태도 존재는 하는데 그것도 명확하게 `boolean`으로 리턴값이 정의되어 있는 거니깐
- 여튼 그래서 컴파일 에러가 나버린다

# 12. 메서드의 리턴값의 타입과 그 리턴값을 받는 변수와의 호환성

- 제목이 좀 긴데 요컨대 같은 타입이거나 다형성으로 받아지는 타입이거나 그러라는 이야기이다
- 근데 비겁하게 함수 상속으로 꼬아놓진 않고 전부 제네릭 타입으로 보기가 나와 있다
- 뭐 여튼 문제에서 돌아오는 타입은 부동소수점 타입인데 `float`로 돌아오니까 `double`로 호환되어도 딱히 상관없다
- 참고로 `dim`은 뭔지 설명도 없고 그냥 자바의 예약어가 아니라는 말만 있다
  - 지금도 몰?루

# 13. 호출된 메서드의 인수의 수, 메서드 선언에 정의된 인수의 수

- 설명은 좀 길지만...
- 요컨대 2개 받기로 정의되어 있는데 호출문에 1개 넣으면 당연히 컴파일 에러가 날 수밖에 없다는 이야기

# 14. `...`으로 정의하는 인수

- 정확히는 가변 길이 인수(可変長引数; Variable length arguments)라고 불린다
- 같은 타입의 다른 갯수를 가진 인수를 모을 뿐이지, 다른 타입끼린 모을 수 없다
- 가변 길이 인수 이외의 인수를 받을 필요가 있을 때엔 반드시 가변 길이 인수를 가장 끝 인수로 해야 한다
```java
void sample(int... num, int value); // 이러면 안 된단 이야기
```
```java
void sample(int value, int... num) // 반드시 끝에 와야 한다
```

# 15. `return`문

- 호출한 곳으로 **돌아온다**라는 뜻
- 그리고 `if`문이랑 조합할 수 있다
- 조건문 없이 쌩으로 리턴이 된 경우엔 그 뒤의 코드는 도달이 불가능하게 되어버린다
  - 이것이 컴파일 에러를 일으킴
- 바보야

# 16. 메서드의 오버로드

- 또는 메서드의 다중 정의
- **인수의 갯수나 타입, 순서가 달라지는 것**으로 같은 이름의 메서드를 오버로드하여 정의할 수 있다
- 아까 이름과 인수를 합쳐서 시그니처라고 했지? 이게 다르면 JVM에서도 다르게 읽어들인다는 특징을 이용하는 게 오버로드라고 할 수 있다
- 리턴값 타입이 다르면 오버로드될 수 없다

# 17. 호출한 메서드는 오버로드된 메서드들 중 어느 것을 호출하는가

- 인수가 다르면 메서드도 다르다
- 시그니처를 보면 된다
- 말인즉슨 둘 다 `int`가 들어가서는 안 됐단 이야기다.
  - 명시적 캐스팅을 하거나 최소한 `2.0` 이렇게 해서 넣어야 들어간다

# 18. 오버로드와 접근 제한자의 관계

- 시그니처가 다르면 오버로드
  - 시그니처가 뭐라고? **메서드명, 인수 타입, 갯수, 순서**
- 여기에 접근 제한자는 포함되어 있지 않다

# 19. 생성자(Constructor)의 접근 제한

- 인스턴스가 생성될 적에 전처리를 담당하는, **메서드**의 일종
- 다른 메서드처럼 자유롭게 정의할 수 있다
- 아래의 3개 규칙을 지킨다면 말이다
  1. 메서드 이름을 클래스 이름과 같게 할 것
  2. 리턴타입은 적을 수 없다
  3. `new`와 같이 쓸 수밖에 없다
- 싱글턴 할 적에 비공개(`private`) 생성자 쓴 적 있지?
- `protected`도 된다. 이 경우엔 상속받은 클래스에서도 접근 가능
- 아무 것도 쓰지 않으면 같은 패키지 내의 클래스만 사용할 수 있다
- `public`도 당연히 된다
  - 어떤 클래스에서도 접근할 수 있다는 뜻이다
- 자바 공식문서에 따르면 접근 제한자는 대충 `public` > `protected` > `(default 또는 package-private)` > `private` 순으로 공개도가 작아지는 모양이다

# 20. 생성자의 리턴 타입은 쓰면 안 된다

- 쓰면 안 된다구욧!!
- 바보야

# 21. 생성자와 초기화자

- 거 참 복잡두 하다
- 코드로 보자
```java
public class Sample {
	{
		// 여기에 초기화자가 들어간다
	}

	public Sample() {
		// 이건 생성자다
	}
}
```
- 대체로 클래스들은 인스턴스를 생성할 적에 사용하는 생성자가 꽤나 많은 편이다
- 근데 이제 이 생성자들이 공유하는 전처리가 좀 있을 때에는, 그보다 더 상위 레벨로 가서 생성자보다 이전에 실행되는 코드를 공통으로 써 놓으면 편할 거라는 이야기다
- 이게 초기화자(initializer)가 하는 일
- 그래서 재정 자체가 생성자 이전에 모든 인스턴스에 적용되는 것이기 때문에, 코드를 뒤에 쓰든 앞에 쓰든 맨 먼저 실행된다
- 지식이 늘었다

# 22. 클래스 변수, 정적 초기화자

- 정적 변수는 인스턴스 생성 없이 그냥 그 클래스의 코드가 로딩될 적에 정적 메모리 영역으로 간다고, 앞에서 기술한 적이 있을 것이다
- 그리고 문제 코드에서는 그 어떤 인스턴스도 생성되지 않았기 때문에 초기화자도, 생성자도 실행되지 않았다
- 따라서 문제에서 `num`을 굳이 불러와야 했었다면, 모든 `int` 변수의 기본 값인 `0`이 나오는 것이다
- ...바보야? 이건 지식이 늘었다 쪽에 가까운 것 같다
- 그래서 정적 클래스 변수를 초기화하고 싶다고 하면 초기화자도 정적으로 하면 된다:
```java
public class Sample {
  static int num;
  static {
    num = 10; // 이러면 힙 영역에서도 num이 10이 된다
  }
  public Sample() {
    num = 100;
  }
}
```

# 23. 생성자에 리턴 타입을 쓰면 안 된다(2)

- 참고로 생성자를 하나도 쓰지 않더라도 자바 컴파일러는 아무 일도 하지 않는 기본 생성자를 추가한다
- 이 때문에 기본 생성자를 찾는 코드가 있을 적에 그게 없어도 실행이 되는 건데
- 문제라면 어떤 형태로든 생성자가 쓰여 있다면 이 기본 생성자는 추가가 되지 않는다는 점
- 그래서 생성자를 찾는 코드가 있어서 그걸 찾았더니 맞는 인수 타입이 안 보이면 컴파일 에러가 나게 된다

# 24. `this`와 `super`

- 뭐 상속에서 이미 배웠다만, 그럼 오버로드된 생성자에서는 어케 쓰는 걸까?
```java
public class Sample {
  private int num;
  Sample() {
    this(1); // 아무 인수도 없이 인스턴스가 생성되면 특정 인수를 오버로드된 생성자에 넣는다
  }
  Sample(int num) {
    this.num = num;
  }
} // end of Sample
```
```java
class Parent {
  protected int num;
  Parent() {
    this(1);
  }
  Parent(int num) {
    this.num = num;
  }
} // end of Parent
public class Child extends Parent {
  Child() {
    super(); // 부모 클래스의 생성자에 넣는다
  }
}
```
- 이거 말고는 방법이 없어요

# 25. `this`를 써서 생성자 부르기

- 맨 앞에 안 쓰면 안 된다

# 26. 자식 클래스의 부모 클래스 요소에의 접근

- 아무 접근 제한자도 없으면 같은 패키지 내에서밖에 사용 불가능하다
- 허나 문제의 코드는 같은 패키지가 아니기에 컴파일 에러

# 27. 다른 패키지에서의 클래스의 요소에의 접근

- UML로 뭔가 써 놨는데 요컨대 `printInfo` 메서드의 `protected` 수식자가 문제가 되는 것
- `protected`: 다시 말하지만 상속 관계 또는 같은 패키지에 속해 있는 클래스에서만 접근 가능하다는 뜻
- `StoryBook` 클래스의 인스턴스를 생성할 적에는, 임포트되어 상속된 `Book` 클래스의 내용이 `StoryBook` 클래스에 정의되어 있는 것이 아니기 떄문에, `Book` 클래스의 정의에서 그대로 인스턴스에 복사된다
- 즉 `Book`에서 `protected`이면, `StoryBook`의 인스턴스에서도 `protected`이며, `Book`의 패키지에 소속되어 있다는 것
- 다른 패키지에 속한 `Main` 클래스에서 `story.printInfo()`로 부른다고 하더라도 불러진 위치가 다른 패키지이기 때문에 컴파일 에러가 일어난다
- 요건 내가 잘못 생각하고 있던 듯하다

# 28. 캡슐화

- 뭐 이러저러 말이 많은데 대체로 데이터 은폐를 목적으로 한 디자인 패턴 같은 거다
- 클래스를 작성할 적에, 나중에 다른 클래스에서 이 클래스의 필드에 잘못 접근하게 될 것을 대비하여서 필드는 일단 `private`로 놔두고, 필드를 변형할 수 있는 메서드만을 `public`으로 만듦으로써 필드의 값 변경을 보호한다는 개념
- 게터와 세터를 제대로 수식자 지켜서 쓴 것이 답이 되겠다

# 29. 원시 타입 멤버가 메서드로 넘어갈 때의 동작

- 요컨대, 어떤 인스턴스의 멤버가 원시(primitive) 타입일 경우, 이것을 클래스 정의 외부의 다른 메서드로 인수로써 넘겨줄 때에는 그냥 그 멤버의 값의 리터럴만이 메서드로 넘어갈 뿐, 그 값이 어디에 속해져 있는지에는 관계가 없는 상태로 넘어간다는 것
- 문제의 코드의 경우, 넘어가는 값은 `s.num`이지만, 사실상 메서드에는 그 어떤 관계도 없이 `10`만이 넘어가기 때문에 딱히 `s.num`에 수정이 가해지는 게 아니라는 뜻이다

# 30. 객체 타입 멤버가 메서드로 넘어갈 때의 동작

- 29번 문제와 다르게 이번에는 메서드에 넘어가는 것이 인스턴스의 참조 그 자체이다
- 이 경우 참조가 넘어가서 그 참조에 있는 내용이 바뀌기 때문에, 클래스 정의 밖에서 수정되어도 정상적으로 인스턴스의 내용도 바뀌게 된다