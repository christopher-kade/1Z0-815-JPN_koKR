# 1. 클래스와 그 인스턴스

- 클래스 파일이 정의되면 인스턴스는 거기서 정의를 복사해 가져와서 메모리 공간에 올려놓은 것
- 단 완전히 복사는 아니고 `static`한 친구들은 인스턴스에는 복사되지 않는다
- 인스턴스 여러 개를 만들면 여러 개가 복사된다는 뜻이다
  - 즉 인스턴스 각각의 다른 값을 가질 수 있게 된다는 뜻이다
- 문제에서는 두 인스턴스는 다르기 때문에 `a.getNum()`을 하면 `a`의 `num`을 가져오게 될 뿐이다

# 2. 참조형 변수가 가진 인스턴스의 참조

- 문제에서 만들어진 인스턴스는 2개긴 하다
  - `apple`, `200`의 필드를 가진 인스턴스 `a`와 `banana`, `100`의 필드를 가진 인스턴스 `b`로
- `a`랑 `b`는 참조형 변수로써 각각의 인스턴스의 실제 주소를 가리키고 있다
- 문제 코드에서 `a = b`라고 하면 `b` 인스턴스의 참조를 `a`에 대입한 것
- 이걸 `printInfo()`로 인스턴스의 필드 내용을 출력하게 되면 `banana, 100`이 출력되게 된다

# 3. 리터럴

- 소문자 `null`이면 조금 고민해 봤을 텐데 대문자 `NULL`이라서 빼도 박도 못하고 문자열이 들어갈 수밖에 없게 되었다
- `null`인 클래스는 `toString`을 하면 `null`이 표시된다는 건 세상이 다 알지만 나머지는 다르단 것이다
- 말인즉슨 자바는 당연하게도 대소문자 구분을 한다는 것이다

# 4. 가비지 컬렉션의 타이밍

- 가비지 컬렉션이라 함은 메모리 용량 절약을 위해 사용하지 않게 된 인스턴스를 메모리에서 지운다는 뜻
- 알다시피 JVM의 매우 특별한 기능 중 하나이다
- **어디로부터도 참조되지 않게 된 인스턴스**가 그 대상
  - `null`을 대입했을 때라던가
  - 새로운 인스턴스의 참조로 변수를 덮어쓴다던가
- 문제에서 묻는 건, 7행까지의 실행이 모두 **끝났을 때**의 가비지 컬렉션 대상을 묻는 거니까, 실행 종료 시점에서 인스턴스가 남아 있는 건 4행에서 생성된 `b`가 가리키는 참조의 인스턴스다.

# 5. `static`한 필드로의 접근

- 자바 소스 파일 `.java`를 컴파일하면 바이트코드인 `.class` 파일이 생성되고, 이 파일을 JVM이 읽게 하는 걸 클래스 파일을 **로드**한다고 표현한다.
- 이게 로드될 적에, `static`(정적)으로 수식된 필드나 메서드는 JVM의 **정적 영역**이라는 별도의 메모리 영역에 배치가 되는데, 이것 이외의 부분은 **힙 영역**이라는 곳에 배치된다.
- 인스턴스가 생성될 때에는 이 힙 영역에 있는 클래스의 정의에 따라서 인스턴스가 생성된다.
- 이때 이 정적 멤버와 그렇지 않은 멤버의 구분은 바이트코드가 로드된 뒤 바로 일어난다.
- 이렇기 때문에 정적 필드는 인스턴스를 만들이 않아도 사용할 수 있게 되는 것이다
- 주의할 점이라면 이 때문에 **인스턴스**에는 정적 멤버가 존재하지 않는다는 점
- 아까도 말했듯이 인스턴스가 생성되면 힙 영역에 있는 부분만 복사되기 때문
- 이 때문에 만일 인스턴스의 참조 변수를 통해서 정적 필드에 접근하게 되면, 각각의 인스턴스에 관계없이 해당 클래스의 인스턴스가 사용하는 모든 해당 필드를 변경하는 것과 같은 것이 된다
- 따라서 답은 마지막으로 수정된 값을 따르게 됨

