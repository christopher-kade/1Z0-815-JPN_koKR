# 1. 대입연산자와 연산자의 동작

- 걍 간단하게, 저렇게 써도 된다 정도로 이해하시길
- 일단 `a += 5`를 계산하면 `a`도 8, 그걸 `b`에 대입하니까 `b`도 8이 된다
- 즉 `a + b`는 16

# 2. `-`(마이너스) 연산자

- 앞에 마이너스를 붙이면 정상적으로 부호가 뒤집히는 모양이다

# 3. 형변환에 관하여

- 되는 거
```java
short b = 128 + 128; // 리터럴은 int가 들어가지만 범위가 short의 범위 내(-32768~32767)이기 때문에 가능
```
- 안 되는 거
```java
// byte a =  0b10000000; // 128이 들어가는데 byte의 범위는 -128~127이므로 컴파일 에러 
byte a = (byte) 0b10000000;
/* 명시적(explicit)으로 이렇게 캐스팅하면,
 * 컴파일러는 안쪽의 이진수를 그대로 byte로 해독하기 때문에
 * 부호 있는 8비트 이진수로 -128을 표현하게 된다 */
// int c = 2 * 3L;
/* 접미사 L을 붙이면 리터럴은 long형이 되고
 * int 리터럴과 long 리터럴을 연산하게 되면
 * int 리터럴 쪽이 long으로 변환되어 연산이 이루어진다
 * 이 때문에 오른쪽의 리터럴은 결국 6L과 같아지고
 * 이걸 int에 대입할 수는 없기 때문에 컴파일 에러
 */
// float d = 10.0; // double형을 float에 넣을 수는 없다: 컴파일 에러
```

# 4. 인크리먼트와 디크리먼트 연산자

- `++`를 앞에 붙이면, 연산이 끝난 뒤에 인크리먼트
- 뒤에 붙이면 연산이 끝나기 전에 인크리먼트
- 즉 이렇게 된다:
```java
int a = 10;
int b = a++ // 10, 그러나 연산 뒤에 11
    + a // 11
    + a-- // 11, 그러나 연산 뒤에 10
    - a-- // 10, 그러나 연산 뒤에 9
    + ++a; // 연산 전에 10, 그러니 10
// 결과적으로 10 + 11 + 10 - 9 + 10 = 32
```
- 답은 맞았는데 내가 판정 생각을 거꾸로 했었다

# 5. 관계연산자

- 부등호는 수치의 크고 작음밖에 비교할 수 없음

# 6. 논리연산자