# 1. 대입연산자와 연산자의 동작

- 걍 간단하게, 저렇게 써도 된다 정도로 이해하시길
- 일단 `a += 5`를 계산하면 `a`도 8, 그걸 `b`에 대입하니까 `b`도 8이 된다
- 즉 `a + b`는 16

# 2. `-`(마이너스) 연산자

- 앞에 마이너스를 붙이면 정상적으로 부호가 뒤집히는 모양이다

# 3. 형변환에 관하여

- 되는 거
```java
short b = 128 + 128; // 리터럴은 int가 들어가지만 범위가 short의 범위 내(-32768~32767)이기 때문에 가능
```
- 안 되는 거
```java
// byte a =  0b10000000; // 128이 들어가는데 byte의 범위는 -128~127이므로 컴파일 에러 
byte a = (byte) 0b10000000;
/* 명시적(explicit)으로 이렇게 캐스팅하면,
 * 컴파일러는 안쪽의 이진수를 그대로 byte로 해독하기 때문에
 * 부호 있는 8비트 이진수로 -128을 표현하게 된다 */
// int c = 2 * 3L;
/* 접미사 L을 붙이면 리터럴은 long형이 되고
 * int 리터럴과 long 리터럴을 연산하게 되면
 * int 리터럴 쪽이 long으로 변환되어 연산이 이루어진다
 * 이 때문에 오른쪽의 리터럴은 결국 6L과 같아지고
 * 이걸 int에 대입할 수는 없기 때문에 컴파일 에러
 */
// float d = 10.0; // double형을 float에 넣을 수는 없다: 컴파일 에러
```

# 4. 인크리먼트와 디크리먼트 연산자

- `++`를 앞에 붙이면, 연산이 끝난 뒤에 인크리먼트
- 뒤에 붙이면 연산이 끝나기 전에 인크리먼트
- 즉 이렇게 된다:
```java
int a = 10;
int b = a++ // 10, 그러나 연산 뒤에 11
    + a // 11
    + a-- // 11, 그러나 연산 뒤에 10
    - a-- // 10, 그러나 연산 뒤에 9
    + ++a; // 연산 전에 10, 그러니 10
// 결과적으로 10 + 11 + 10 - 9 + 10 = 32
```
- 답은 맞았는데 내가 판정 생각을 거꾸로 했었다

# 5. 관계연산자

- 부등호는 수치의 크고 작음밖에 비교할 수 없음

# 6. 논리연산자

- `||`는 OR고 `&&`은 AND다.
- 사실 `&`이랑 `&&`의 재정 차이가 존재한다.
```java
int a = 5;
boolean b = a < 3 && ++a < 10;
/* 이렇게 두 개의 논리연산자가 붙어 있으면 쇼트서킷 연산자라 부른댄다.
 * 말인즉슨 왼쪽 연산이 false가 나오면 오른쪽 연산은 수행하지 않고
 * 그냥 그대로 false를 뱉는다는 뜻.
 * 즉, 이럴 때 a는 인크리먼트 없이 그냥 5인 채이다. */
```
```java
int a = 5;
boolean b = a < 3 & ++a < 10;
/* 만일 반드시 두 개의 연산이 동시에 true이길 원한다면 &을 한 개만 사용.
 * 이럴 땐 a의 인크리먼트가 발생하므로 이후에 a는 6이 된다. */
```

# 7. 연산자의 우선순위

- 일단 직관적으로는 수학적인 우선순위가 된다만, 좀 더 자세하게 파고들면 다음과 같다:

| 우선순위 | 연산자 |
|:-:|---|
| 높다 | `[`, `]`, `.`, (인수 리스트의)`x++`, `x--` |
| ⇓ | `++x`, `--x`, `+x`, `~`, `!` |
| ⇓ | `new`, (자료형)`x` |
| ⇓ | `*`, `/`, `%` |
| ⇓ | `+`, `-` |
| ⇓ | `<<`, `>>`, `>>>` |
| ⇓ | `<`, `>`, `<=`, `>=`, `instanceof` |
| ⇓ | `==`, `!=` |
| ⇓ | `&` |
| ⇓ | `^` |
| ⇓ | `\|` |
| ⇓ | `&&` |
| ⇓ | `\|\|` |
| ⇓ | `?:` |
| 낮다 | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `!=`, `<<=`, `>>=`, `>>>=` |
- 거 참 많기도 하다. 뭐 근데 대충 감으로 알게 될 거라 믿는다...

# 8. 동일성과 동치성

- 자바에는 '같다'라는 말에 두 가지 의미가 있는데
  - 하나는 같은 인스턴스라는 뜻이고
  - 하나는 같은 값이란 뜻이다
- 같은 인스턴스를 **동일**, 같은 값을 **동치**라고 한다
- 즉 '변수 a와 변수 b는 동일하다'려고 말하려면 다음과 같은 작업이 필요하다:
```java
Object a = new Object();
Object b = a; // 변수 a의 참조를 복사하여 변수 b에 대입
```
- 인스턴스를 만들게 되면 `a`는 그 인스턴스가 있는 메모리 주소를 가리키게 되는데, `b`도 똑같은 주소를 가리키게 한다는 뜻
- 그리고 이 동일성은, `==` 연산자로 판정하게 된다
- 하지만 문제에서는 그렇게 **동일하게** 만들어 놓고는 다시 새로운 인스턴스의 참조를 `a`에 옮겨놨기 때문에, 동일성이 사라지게 되어버린다

# 9. 동치성(8번에서 동일성을 다뤘기에)

- `java.lang.Object` 원시 클래스에는 `java.lang.Object.equals(Object obj)` 메서드가 존재한다
```java
public boolean equals(Object obj) {
  return (this == obj);
}
```
- 그리고 모든 객체는 이 메서드를 상속받기 때문에, 문제에서는 메서드를 오버라이드했다:
```java
@Override
public boolean equals(Object obj) {
  if (obj == null) {
    return false;
  }
  if (obj instanceof Sample) {
    Sample s = (Sample) obj; // 동치 비교를 위해 캐스팅
    return s.num == this.num; // num만을 비교함
  }
  return false;
}
```

# 10. 인스턴스의 동치성(`equals` 메서드의 오버로드)

- `a`객체와 `b`객체는 어디까지나 `Object`형 객체이기 때문에, `equals`로 둘을 비교했을 경우에는 `Object` 객체를 받는 메서드로 들어가게 된다
- 문제에서는 `Sample`형 객체를 받는 메서드로 오버로드가 된 상황
- 이 경우 `Object` 클래스에서는 `equals`로 동일성을 비교하게 되기 때문에 당연히 서로 다른 인스턴스 둘은 필드 변수가 같더라도 동일하지는 않으므로 `false`가 출력되게 된다

# 11. 동치성과 `equals` 메서드의 오버라이드

- `equals` 메서드의 오버라이드에는 다음과 같은 조건이 필요함:
  - `null` 이외의 참조값 `x`가 있다면 `x.equals(x)`는 `true`를 돌려줄 것(반사성)
  - `null` 이외의 참조값 `x`와 `y`가 있다면 `x.equals(y)`가 `true`일 때 `y.equals(x)`도 `true`를 돌려줄 것(대칭성)
  - `null` 이외의 참조값 `x`, `y`, `z`가 있고 `x.equals(y)`가 `true`이고 `y.equals(z)`가 `true`이면 `x.equals(z)`도 `ture`일 것(추이성)
  - `null` 이외의 참조값 `x`와 `y`가 있다면 `x.equals(y)`를 여러 번 호출해도 비교에 사용된 정도가 변경되지 않았다면 전부 `true` 아니면 `false`를 돌려줄 것
  - `null` 이외의 참조값 `x`가 있다면 `x.equals(null)`은 `false`를 돌려줄 것
  - 쓰다 보면 이항관계에서의 동일성에 적용되는 법칙들임을 알 수 있다
- 위에서 언급한 `Object` 클래스의 `equals` 메서드는 `==` 연산자로 두 인스턴스의 동일성을 비교하기에, `null`을 넣으면 무조건 `false`가 돌아올 수밖에 없다

# 12. 문자열 리터럴의 동일성

- 문제의 코드의 경우, 직관적으로는 `a`와 `b`는 다른 `String` 인스턴스이기 때문에 `==`으로는 `false`가 출력될 것 같지만, '문자열 상수 풀(String Constant Pool)'이라는 자바만의 특별한 메모리 공간의 특성 때문에 다른 결과가 나온다.
- 문자열 상수 풀, 또는 문자열 풀이란, 자바에서 메모리 사용량을 최적화하기 위해 문자열을 '재사용'하기 위하여 정수용 메모리 공간에 만들어진(아마도 `CharSequence`라서 그런 걸까?) 특수한 메모리 사양
- 즉 문제의 `"sample"`이란 문자열을 만들면, 문자열 풀에 이 문자열이 저장되고 참조가 이것을 가리키게 되며
- 만일 똑같이 `"sample"`로 다른 인스턴스를 만들면 문자열 인스턴스를 하나 더 만드는 게 아니라 인스턴스의 참조가 문자열 풀에 있는 똑같은 장소를 가리키게 된다는 것
- 따라서 같은 참조를 가리키느냐(=동일성)를 판정하는 `==` 연산자로 같은 문자열 풀을 가리키는 인스턴스끼리 비교시키면 `true`가 나오게 된다
- 그리고 동치성을 비교하는 `equals` 메서드로도 이 두 인스턴스는 `true`가 나온다
- 이건 내가 바보가 아니라 지식이 늘었다고 해야 한다

# 13. 동일성, 동치성, `equals`

- 그럼 `new` 연산자를 이용해 명시적으로 새로운 인스턴스를 만들면?
- `a`에는 인스턴스용 메모리 공간에 인스턴스의 참조가 들어가고, 리터럴로 대입한 `b`눈 문자열 풀에 의해 정수용 메모리 공간에 만들어진 인스턴스의 참조가 들어가게 된다
- 즉 둘은 다른 참조를 가리키므로 `==` 연산은 `false`가 나온다
- `String` 클래스의 `equals` 메서드는 다음과 같다
- 이해를 쉽게 하기 위해 간단화한 건지 진짜 자바 사양이 이런지는 몰?루
```java
@Override
public boolean equals(Object anObject) {
  // 전략
  if (anObject instanceof String) {
    // 중략
    if (n == anotherString.value.length) {
      char v1[] = value;                // 원래 인스턴스의 문자열
      char v2[] = anotherString.value;  // 인수로 받아온 문자열
      int i = 0;
      while (n-- != 0) {
        if (v1[i] != v2[i])             // 한 문자씩 확인
          return false;
        i++;
      }
      return true;
    }
  }
  return false;
}
```