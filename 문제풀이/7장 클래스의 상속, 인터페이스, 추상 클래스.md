# 1. 상속이란?

- 상속을 이용한 클래스가 로딩될 때는 기본적으로 부모 클래스의 정의와 거기서 변경된 정의만이 합해져서 로딩되는 식이다
- 문제의 코드에서 정의되어 있지 않은 부분이 있어야 에러가 나지 않는다

# 2. 상속한 클래스는 무엇을 상속받는가?

- 일단 **생성자**와 **`private`필드 및 메서드**는 상속받지 않는다!
- 디폴트 수식자의 경우 같은 패키지 내, 내지는 자신 내에서만 사용 가능함: 접근 불가
- `protected` 필드나 메서드의 경우 다른 패키지에 있어도 임포트하여 상속하면 접근 가능

# 3. 인터페이스의 기초지식

- 상속받는 다른 클래스가 멤버들을 **다루는 법**을 규정해 놓은 것이라 할 수 있다
- 규정된 모든 추상 메서드는 `public`으로 취급
- 즉 수식자를 적지 않아도 전부 `public` 취급이란 소리
- 사용법만 적어놓은 것이므로 인스턴스화할 수 없음
- 자바에서 다중 클래스를 상속받을 수는 없지만 다중 인터페이스를 상속받을 수는 있음
- 이외에도 `final`으로 변경되지 않는 필드를, `static`으로 인스턴스 생성을 필요로 하지 않는 멤버를 규정할 수 있다
- 추상 클래스의 경우 인터페이스의 추상 메서드를 구현하지 않아도 된다
  - 실제 클래스에서는 반드시 구현해야 한다

# 4. 디폴트 메서드

- 인터페이스를 상속받은 일반 클래스는 인터페이스에 정의되어 있는 추상 페이스를 반드시 모두 구현해야만 한다
- 근데 예컨대, 공통으로 자식 클래스들이 가지고 있는 요소가 있다 치면, 그 자식 클래스들 위에 추상 클래스로써 공통 클래스를 구현한 식으로 클래스를 하나 더 정의할 수도 있을 것이다
- 이럴 적에 `default` 수식자를 사용하면 이 기능으로 편리하게 기본 기능을 정의할 수 있다
- 덕분에 인터페이스에서도 `default` 수식자로 별도의 오버라이드가 없을 경우에 상속받은 클래스에서 사용될 코드를 정의할 수 있게 된 것이다
```java
public interface A {
  default void sample() {
    sysout("Sample");
  } // 인터페이스인데도 함수 정의가 가능해진다
}
```
```java
public class B implements A {} // 정의를 안 했으니 디폴트 구현이 사용됨
```
```java
public class Main {
  public static void main(String[] args) {
    A a = new B();
    a.sample(); // 정상적으로 일반 클래스 상속처럼 작동한다
  }
}
```

# 5. 디폴트 메서드의 오버라이드

- 그러니까, B 클래스는 괜찮다.
- 근데 A 클래스에서 오버라이드하려고 한 게, 모든 클래스가 상속받은 것으로 간주하는 `java.lang.Object`에 존재하는 `toString()` 메서드라는 게 문제다
  - 요걸 디폴트 메서드로 오버라이드하려고 하면, 컴파일 에러가 발생한다

# 6. 오버라이드한 메서드 정의에서 디폴트 메서드를 부르는 방법

- 답은 `A.super.sample()`이다 일단
  - 디폴트 메서드를 부를 때의 문법이라 생각하자. 여기서 A는 디폴트 메서드가 정의되어 있는 인터페이스의 이름이 된다.
- 근데 문제가 있다면 `super` 키워드는 끝가지 거슬러 올라가는 게 아니라 **그냥 한 층 위의**정의를 부른다는 것이다
- 문제의 C 클래스에서는 C의 상위 클래스는 A가 아닌 B이므로, 상기와 같이 코드를 써 봤자 컴파일 에러가 날 뿐이다

# 7. 인터페이스 두 개 이상을 구현할 적의 디폴트 메서드 호출 방법

- 일단 정의도 구현 자체도 틀리진 않다
```java
public interface A {
  default void test() {
    sysout("A");
  }
}
```
```java
public interface B {
  default void test() {
    sysout("B");
  }
}
```
```java
public class Main implements A, B {
  public static void main(String[] args) {
    // 이제 여기가 문제인 건데
    // 답은 위에서 말한 것처럼 어느 부모 클래스를 super로 부를지 특정하는 것이다
    new Main.test();
  }
  @Override
  public void test() {
    A.super.test(); // 요렇게
  }
}
```
- 참고로 인터페이스를 다중으로 구현한 인터페이스의 디폴트 메서드를 오버라이드해서 만들 시에도 똑같이 할 수 있다

# 8. 추상 클래스의 기초지식

- 코드로 알아보자
```java
public abstract class AbstractSample {
  public void methodA() {
    // 구상 메서드
  }
  public abstract void methodB(); // 정의부가 없이 자식 클래스에서 구현한다
}
```
- 인스턴스화할 수 없다
- 선택지 E가 사람을 혼란시키는데, 추상 클래스는 인터페이스와 달리 구상 메서드를 정의할 수 있기 때문에 모든 **추상 메서드를** 자식 클래스에서 구현해야 하지만 구상 메서드는 딱히 일부러 오버라이드하지 않아도 된다
- 일반적인 클래스 상속처럼 먼저 정의된 내용이 그대로 인스턴스에 들어간다

# 9. 추상 클래스에서의 메서드의 호출

- 어차피 추상 클래스는 인스턴스를 못 만드니까, 중간에 미구현 메서드가 있어도 상속된 구상 클래스에서 이미 구현되었을 것이므로 코드는 정상 작동한다
- 바보야

# 10. 오버라이드(카사네 테토 노래 아님)

- ~~위에서 드립 잘 참았으면서 왜 여기서 뒤늦게 치는거임~~
- 오버로드를 같은 이름을 가진 메서드를 다른 시그니처로 **다중정의**하는 거라면, 오버라이드는 같은 시그니처를 가진 메서드를 상속받은 클래스에서 **재정의**하는 것
- 공변 반환값(Covariant return value)이라는 개념이 Java SE 5부터 존재는 해서, 예컨대 부모 클래스에서 `Number` 형으로 먼저 메서드가 정의되어 있을 때, 리턴값을 `Integer`로, 다시 말해 리턴 값의 자식의 참조형으로 정의해도 괜찮다
  - 즉 리턴값이 똑같지 않아도 된다는 이야기

# 11. 오버라이드를 할 때의 규칙

- 시그니처가 같을 것
- 리턴값이 같은 타입이거나 자식 클래스 타입일 것
- 접근 제한자는 똑같거나, **더 넓은 접근 범위**일 것
- 따라서 바꿀 수 있으며, 가능한 선택지는 `protected` 아니면 `public`이다
- 마치 접근범위로써의 다형성 같은 느낌이다

# 12. 상속 관계에 있는 클래스가 같은 이름의 필드를 공유할 때

- 그러니까 문제처럼 `String val = "A";`일 때랑 `String val = "B";`일 때, 어느 것이 우선되느냐는 이야기이다
- 일단 필드를 참조했을 때에는 변수 형태로 선언된 쪽을 사용한다(그러니까 `b.val` 같은 거)
- 메서드를 불렀을 때에는 메서드 내의 지시를 사용한다
- 그런데 메서드는 A 클래스에 정의되어 있고, 딱히 B 클래스에 오버라이드되어 있는 것도 아니기 때문에, 이 메서드는 기본적으로 A 클래스의 값을 참조하고 있었으므로 A 쪽의 필드가 사용된다
- 다형성으로 인스턴스를 생성했을 경우에는 선언한(그러니까 `A a = new B();` 같은 거) 변수의 속성을 따른다
- 이러한 판정은 컴파일 시에 정해진다
- 컴파일 시에는 어떤 타입의 인스턴스가 동작하는지 체크하지 않기 때문에 선언된 변수의 타입만으로 판단을 하기 때문이다

# 13. 인터페이스의 구현

- 아까도 말했지만 인터페이스는 클래스의 틀만을 제공하는 것이라서, 말하자면 그 틀이 어떻게 생겼는지 타입으로 선언함으로써 다형성을 염두에 둘 수 있는 것이다
- 상속으로 인터페이스에 정의된 메서드를 구현해도 동작한다는 판정

# 14. 다형성

- 말이 좀 복잡해 보이는데, 요점은 `Worker`형으로 선언된 클래스에서 `Worker`에 정의되지 않은 메서드를 불렀다는 것이 문제가 된다는 것
- 다른 건 정의가 되어 있으므로 괜찮다

# 15. 다형성이 성립하려면

- 바보야
- 바보야!!!
- 인터페이스의 인스턴스를 왜 만드는데!!!

# 16. 업캐스팅과 다운캐스팅

- 예컨대 클래스 A가 있고 B가 `extends A`일 때, `A a = new B();`로 선언하면 업캐스팅이라고 한다. 부모 클래스 타입으로 선언한다는 뜻이다.
- A에 정의되지 않은 메서드를 호출할 때에는 `B b = (B) a;`로 형변환을 시켜 줄 필요가 있고, 이걸 다운캐스팅이라 한다.
- 뭐 말이 복잡한데 여튼 정의되지 않은 코드를 불러오려면 형변환 절차가 필요하다 그 말이다.

# 17. 다운캐스팅을 할 때의 호환성

- 예컨대 문제에서 A 타입의 인스턴스를 생성했는데, 프로그래머가 B 타입으로 다운캐스팅을 한다는 건 컴파일러에게 이 타입의 캐스팅이 이루어져도 클래스의 호환성이 보장된다는 일종의 보증을 하는 셈이라는 것
- 컴파일 시에 이 보증은 그대로 에러 없이 넘어가고, 대신에 런타임 시에 형변환에 실패했다는 예외가 던져진다(아마도 `java.lang.ClassCastException`)
- 이는 A 타입으로 생성된 인스턴스에는 A를 상속받은 B의 변경부분이 포함되어 있지 않기 때문이다

# 18. 필드에 접근하는 방법

- 제대로 정보 은폐가 잘 이루어져 있는 클래스인데, 그럼 생성자로 필드를 초기화하려면?
- 일단 맨날 잘 쓰는 `this.num = num;`이 있을 수 있겠다
- 그리고 클래스 내에 정의되어 있는 메서드를 쓸 수도 있기는 있을 것이다. `setNum(num);`으로.
  - 근데 `this` 놔두고 굳이?

# 19. `this`가 가리키는 대상

- 반복해서 말하지만 상속된 클래스의 인스턴스를 생성하면 그대로 부모 클래스에서 멤버들이 로딩됨
- `this`는 이 상황에서 마치 서로 다른 두 클래스의 인스턴스인 것처럼 원래 정의되어 있는 곳을 가리키게 됨
- 문제에서 `Child` 타입으로 인스턴스를 생성하면, `getName()`에서 돌아오는 `this.name`은 `Child`에 기술되어 있는 `name`이 아닌 `Parent`에 기술되어 있는 `name`이라는 이야기
- 즉 `child.name = "sample";`로 값을 변경할지언정 `parent.name`이 변경된 것이 아니기 때문에 이 필드는 그대로 기본값인 `null`을 출력할 수밖에 없게 된다

# 20. 상속관계에 있을 때의 생성자 순서 재정

- 역시 동일하게, 그대로 부모 클래스에서 인스턴스가 로딩되기 때문에 생성자 역시 실행하게 되고, 이는 자식 클래스의 생성자 맨 앞에 기본값으로 `super();`를 넣는 것으로 해결한다.
- 이 때문에 부모 클래스의 생성자가 먼저 실행된다는 재정
- 이는 기본 틀과 변경점이라는 상속의 기본 개념과도 일치함

# 21. 도대체 이럴 필요가 왜 있죠

- 아니 코드 직접 보셈 이게 지금 읽으라고 있는 코드임?
```java
class Parent {
  public Parent() {
    sysout("A");
  }
  public Parent(String val) {
    this();
    sysout(val);
  }
}
```
```java
class Child extends Parent {
  public Child() {
    super("B"); // 그러니까 A B 이렇게 출력된다
    sysout("C"); // 여기까지 하면 A B C 순서겠지
  }
  public Child(String val) {
    this();
    sysout(val);
  }
}
```
```java
public class Main {
  public static void main(String[] args) {
    new Child("D"); // A B C D
  }
}
```
- 뭐 근데 차근차근 따라가면 안 어렵지?